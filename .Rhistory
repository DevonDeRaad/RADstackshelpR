#' There are slots for varying the n parameter across M-1, M, and M-1 (as recommended by Paris et al. 2017).
#' After running stacks with each of the n options, plug the output vcf files into this
#' function to visualize the effect of varying m on number of SNPs and loci built to
#' recognize which value optimizes the n parameter for your dataset at the 'R80' cutoff (Paris et al. 2017).
#'
#' @param vcfR a vcfR object
#' @param nequalsM Path to the input vcf file for a run when n=M
#' @param nequalsMplus1 Path to the input vcf file for a run when n=M+1
#' @return A dataframe showing the number of SNPs and loci retained across filtering levels for each n value.
#' @export
hard.filter.vcf <- function(vcfR, depth=NULL, gq=NULL){
#extract depth from the vcf
dp.matrix<- vcfR::extract.gt(vcfR, element='DP', as.numeric=TRUE)
#calculate the SNPs that fall below the depth filter
i<-round((sum(dp.matrix < depth, na.rm = TRUE)/sum(!is.na(dp.matrix)))*100, 2)
#report filter
print(paste0(i,"% of genotypes fall below a read depth of ",depth," and were converted to NA"))
#convert to NAs
dp.matrix[dp.matrix < depth] <- NA
vcfR@gt[,-1][ is.na(dp.matrix) == TRUE ] <- NA
#extract gq from the vcf
gq.matrix<- vcfR::extract.gt(vcfR, element='GQ', as.numeric=TRUE)
#calculate the SNPs that fall below the gq filter
j<-round((sum(gq.matrix < gq, na.rm = TRUE)/sum(!is.na(gq.matrix)))*100, 2)
#report filter
print(paste0(j,"% of genotypes fall below a genotype quality of ",gq," and were converted to NA"))
#convert to NAs
gq.matrix[gq.matrix < gq] <- NA
vcfR@gt[,-1][ is.na(gq.matrix) == TRUE ] <- NA
return(vcfR)
}
x<-vcfR::read.vcfR("~/Downloads/3bConUnfilteredVCF/bi.allelic.unlinked.conserv.ery.recode.vcf")
hard.filter.vcf(x)
devtools::document()
devtools::document()
warnings()
rm(list = ls())
rm(list = ls())
devtools::document()
warnings()
devtools::document()
usethis::use_vignette("filtering.vignette")
usethis::use_vignette("filtering_vignette")
library(RADstackshelpR)
library(vcfR)
#read in vcf as vcfR
vcfR <- read.vcfR("~/Desktop/aph.data/populations.snps.vcf")
### check the metadata present in your vcf
vcfR
vcfR@fix[1:10,1:8]
vcfR@gt[1:10,1:2]
#generate popmap file. Two column popmap with the same format as stacks, and the columns must be named 'id' and 'pop'
popmap<-data.frame(id=colnames(vcfR@gt)[2:length(colnames(vcfR@gt))],pop=substr(colnames(vcfR@gt)[2:length(colnames(vcfR@gt))], 3,11))
View(popmap)
#rename mislabeled sample
colnames(vcfR@gt)[colnames(vcfR@gt) == "A_californica_334171"]<-"A_woodhouseii_334171"
#generate popmap file. Two column popmap with the same format as stacks, and the columns must be named 'id' and 'pop'
popmap<-data.frame(id=colnames(vcfR@gt)[2:length(colnames(vcfR@gt))],pop=substr(colnames(vcfR@gt)[2:length(colnames(vcfR@gt))], 3,11))
#hard filter to minimum depth of 5, and minimum genotype quality of 30
vcfR<-hard.filter.vcf(vcfR=vcfR, depth = 5, gq = 30)
dev.off()
plot.new()
dev.off()
is.null(popmap)
!is.null(popmap)
dim(vcfR)
#run function to drop samples above the threshold we want from the vcf
vcfR<-missing.by.sample(vcfR=vcfR, cutoff = .91)
#run function to drop samples above the threshold we want from the vcf
vcfR<-missing.by.sample(vcfR=vcfR, cutoff = .91)
#subset popmap to only include retained individuals
popmap<-popmap[popmap$id %in% colnames(vcfR@gt),]
#reorder vcf to group by species
vcfR@gt<-vcfR@gt[,c(1:19,21:56,20,57:95)]
colnames(vcfR@gt)
#reorder vcf to group by species
vcfR@gt<-vcfR@gt[,c(1:19,21:56,20,57:95)]
colnames(vcfR@gt)
#read in vcf as vcfR
vcfR <- read.vcfR("~/Desktop/aph.data/populations.snps.vcf")
#rename mislabeled sample
colnames(vcfR@gt)[colnames(vcfR@gt) == "A_californica_334171"]<-"A_woodhouseii_334171"
colnames(vcfR@gt)
#generate popmap file. Two column popmap with the same format as stacks, and the columns must be named 'id' and 'pop'
popmap<-data.frame(id=colnames(vcfR@gt)[2:length(colnames(vcfR@gt))],pop=substr(colnames(vcfR@gt)[2:length(colnames(vcfR@gt))], 3,11))
#hard filter to minimum depth of 5, and minimum genotype quality of 30
vcfR<-hard.filter.vcf(vcfR=vcfR, depth = 5, gq = 30)
#execute allele balance filter
vcfR<-filter.allele.balance(vcfR)
#visualize and pick appropriate max depth cutoff
max.depth(vcfR)
#filter vcf by the max depth cutoff you chose
vcfR<-max.depth(vcfR, maxdepth = 100)
vcfR<-missing.by.sample(vcfR=vcfR, cutoff = .91)
colnames(vcfR@gt)
#' recognize which value optimizes the m parameter for your dataset at the 'R80' cutoff (Paris et al. 2017).
#'
#' @param m3 Path to the input vcf file for a run when m=3
#' @param m4 Path to the input vcf file for a run when m=4
#' @param m5 Path to the input vcf file for a run when m=5
#' @param m6 Path to the input vcf file for a run when m=6
#' @param m7 Path to the input vcf file for a run when m=7
#' @return A list containing two dataframes, 'depth.df' showing depth per sample for each m value,
#' and 'm.df' showing the number of SNPs and loci retained at various filtering levels for each m value
#' @export
optimize_m <- function(m3=NULL,m4=NULL,m5=NULL,m6=NULL,m7=NULL){
#initialize empty depth.df
depth.df<- data.frame(m=character(), avg.depth=numeric())
#initialize empty m.df
m.df<- data.frame(m=character(), filt=as.numeric(), snps=numeric(), V4=character())
#set vector of m identifiers
ms<-c("m3","m4","m5","m6","m7")
#start on first position in vector of m identifiers
j=1
#open for loop for each m identifier
for(x in list(m3,m4,m5,m6,m7)){
#open if else statement, if no m of given value, move j up to next m identifier, else calculate snps/loci retained
if(is.null(x)){j=j+1} else{
#calculate depth first
##read in vcfR
vcf.r<- vcfR::read.vcfR(x) #read in all data
###calc avg depth of each individual
dep<- (colSums(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE), na.rm = T)) / (colSums(is.na(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE)) == "FALSE"))
###rep m identifier, times = number of samples in the vcf
m<- rep(ms[j], times = length(dep))
###cbind depth and m identifier into depth df
depth.df<- rbind(depth.df, as.data.frame(cbind(m,dep)))
#initialize vectors to hold filt level, snps retained, poly loci retained
filt<- vector("numeric", length = 11)
snps<- vector("numeric", length = 11)
poly.loci<- vector("numeric", length = 11)
##run loop to fill up vectors with a value for each filter level
k=1
for (i in c(0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1)){
#calculate the completeness cutoff for each snp to be retained
filt[k]<-i
#calculate the number of snps retained at this cutoff
snps[k]<-nrow(vcf.r@gt[(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i),])
#calculate number of polymorphic loci retained at this cutoff
poly.loci[k]<-length(unique(stringr::str_extract(vcf.r@fix[,3][(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i)], pattern = "[0-9]+")))
k=k+1
#close for loop
}
##cbind these three vectors with m identifier and append it all to the m df
snpsubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, snps, rep("snp", times = 11)))
locisubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, poly.loci, rep("loci", times = 11)))
#match colnames so you can rbind these together in tidy format
colnames(locisubset)[3]<-"snps"
#append to existing df
m.df<- rbind(m.df, as.data.frame(rbind(snpsubset,locisubset)))
#set j for the next m identifier for next time we go through this loop
j=j+1
#close if else statement
}
#close for loop
}
#take depth df output from all of these possibilities
#plot hist of depth at each m value on same plot
depth.df$m<-as.factor(depth.df$m)
depth.df$dep<-as.numeric(depth.df$dep)
print("Visualize how different values of m affect average depth in each sample")
print(
ggplot2::ggplot(depth.df, ggplot2::aes(x = dep, y = m, fill = m, color = m)) +
ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = .35, cex=.5) +
ggplot2::theme_classic() +
ggplot2::labs(x = "average depth in each sample", y = "m value (minimum stack depth)") +
ggplot2::theme(legend.position = "none")
)
#take m df output from all these possibilities
#plot number of SNPs retained colored by m at each filt level, as open circles
#plot the number of polymorphic loci retained colored by m at each filt level, as closed circles
#plot a vertical line at x=.8
#return a message as output telling the user to pick the m value with the most polyloci retained at r80 (.8)
#rename columns
colnames(m.df)<-c("m","filt","retained","snp.locus")
m.df$m<-as.character(m.df$m)
m.df$filt<-as.numeric(as.character(m.df$filt))
m.df$retained<-as.numeric(as.character(m.df$retained))
m.df$snp.locus<-as.character(m.df$snp.locus)
print("The optimal m value returns the most polymorphic loci in the 80% complete matrix (Paris et al. 2017)")
print(
ggplot2::ggplot(m.df, ggplot2::aes(x=filt, y=retained, col = m, shape=snp.locus))+
ggplot2::geom_point(alpha = .75, size=3)+
ggplot2::ggtitle("total SNPs and polymorphic loci retained by filtering scheme")+
ggplot2::xlab("fraction of non-missing genotypes required to retain each SNP (0-1)")+
ggplot2::ylab("# SNPs/loci")+
ggplot2::theme_light()+
ggplot2::geom_vline(xintercept=.8)+
ggplot2::labs(col = "min. stack depth", shape="")
)
#return the depth and snp/loci dataframes in case you want to do your own visualizations
out <- list()
out$depth<-depth.df
out$m.comparisons<-m.df
return(out)
#close function
}
setwd("/Users/devder/Desktop/chalcophaps.rad")
optimize_m(m3="m3.vcf",
m4="m4.vcf",
m5="m5.vcf",
m6="m6.vcf",
m7="m7.vcf")
#initialize empty depth.df
depth.df<- data.frame(m=character(), avg.depth=numeric())
#initialize empty m.df
m.df<- data.frame(m=character(), filt=as.numeric(), snps=numeric(), V4=character())
#set vector of m identifiers
ms<-c("m3","m4","m5","m6","m7")
#start on first position in vector of m identifiers
j=1
x="m3.vcf"
#calculate depth first
##read in vcfR
vcf.r<- vcfR::read.vcfR(x) #read in all data
###calc avg depth of each individual
dep<- (colSums(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE), na.rm = T)) / (colSums(is.na(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE)) == "FALSE"))
###rep m identifier, times = number of samples in the vcf
m<- rep(ms[j], times = length(dep))
###cbind depth and m identifier into depth df
depth.df<- rbind(depth.df, as.data.frame(cbind(m,dep)))
#initialize vectors to hold filt level, snps retained, poly loci retained
filt<- vector("numeric", length = 11)
snps<- vector("numeric", length = 11)
poly.loci<- vector("numeric", length = 11)
##run loop to fill up vectors with a value for each filter level
k=1
for (i in c(0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1)){
#calculate the completeness cutoff for each snp to be retained
filt[k]<-i
#calculate the number of snps retained at this cutoff
snps[k]<-nrow(vcf.r@gt[(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i),])
#calculate number of polymorphic loci retained at this cutoff
poly.loci[k]<-length(unique(stringr::str_extract(vcf.r@fix[,3][(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i)], pattern = "[0-9]+")))
k=k+1
#close for loop
}
##cbind these three vectors with m identifier and append it all to the m df
snpsubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, snps, rep("snp", times = 11)))
locisubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, poly.loci, rep("loci", times = 11)))
#match colnames so you can rbind these together in tidy format
colnames(locisubset)[3]<-"snps"
#append to existing df
m.df<- rbind(m.df, as.data.frame(rbind(snpsubset,locisubset)))
View(m.df)
View(depth.df)
vcf.r@fix
View(depth.df)
View(m.df)
#' recognize which value optimizes the m parameter for your dataset at the 'R80' cutoff (Paris et al. 2017).
#'
#' @param m3 Path to the input vcf file for a run when m=3
#' @param m4 Path to the input vcf file for a run when m=4
#' @param m5 Path to the input vcf file for a run when m=5
#' @param m6 Path to the input vcf file for a run when m=6
#' @param m7 Path to the input vcf file for a run when m=7
#' @return A list containing two dataframes, 'depth.df' showing depth per sample for each m value,
#' and 'm.df' showing the number of SNPs and loci retained at various filtering levels for each m value
#' @export
optimize_m <- function(m3=NULL,m4=NULL,m5=NULL,m6=NULL,m7=NULL){
#initialize empty depth.df
depth.df<- data.frame(m=character(), avg.depth=numeric())
#initialize empty m.df
m.df<- data.frame(m=character(), filt=as.numeric(), snps=numeric(), V4=character())
#set vector of m identifiers
ms<-c("m3","m4","m5","m6","m7")
#start on first position in vector of m identifiers
j=1
#open for loop for each m identifier
for(x in list(m3,m4,m5,m6,m7)){
#open if else statement, if no m of given value, move j up to next m identifier, else calculate snps/loci retained
if(is.null(x)){j=j+1} else{
#calculate depth first
##read in vcfR
vcf.r<- vcfR::read.vcfR(x) #read in all data
###calc avg depth of each individual
dep<- (colSums(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE), na.rm = T)) / (colSums(is.na(vcfR::extract.gt(vcf.r, element='DP', as.numeric=TRUE)) == "FALSE"))
###rep m identifier, times = number of samples in the vcf
m<- rep(ms[j], times = length(dep))
###cbind depth and m identifier into depth df
depth.df<- rbind(depth.df, as.data.frame(cbind(m,dep)))
#initialize vectors to hold filt level, snps retained, poly loci retained
filt<- vector("numeric", length = 11)
snps<- vector("numeric", length = 11)
poly.loci<- vector("numeric", length = 11)
##run loop to fill up vectors with a value for each filter level
k=1
for (i in c(0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1)){
#calculate the completeness cutoff for each snp to be retained
filt[k]<-i
#calculate the number of snps retained at this cutoff
snps[k]<-nrow(vcf.r@gt[(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i),])
#calculate number of polymorphic loci retained at this cutoff
poly.loci[k]<-length(unique(vcf.r@fix[,1][(rowSums(is.na(vcf.r@gt))/ncol(vcf.r@gt) <= 1-i)]))
k=k+1
#close for loop
}
##cbind these three vectors with m identifier and append it all to the m df
snpsubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, snps, rep("snp", times = 11)))
locisubset<-as.data.frame(cbind(rep(ms[j], times=11), filt, poly.loci, rep("loci", times = 11)))
#match colnames so you can rbind these together in tidy format
colnames(locisubset)[3]<-"snps"
#append to existing df
m.df<- rbind(m.df, as.data.frame(rbind(snpsubset,locisubset)))
#set j for the next m identifier for next time we go through this loop
j=j+1
#close if else statement
}
#close for loop
}
#take depth df output from all of these possibilities
#plot hist of depth at each m value on same plot
depth.df$m<-as.factor(depth.df$m)
depth.df$dep<-as.numeric(depth.df$dep)
print("Visualize how different values of m affect average depth in each sample")
print(
ggplot2::ggplot(depth.df, ggplot2::aes(x = dep, y = m, fill = m, color = m)) +
ggridges::geom_density_ridges(jittered_points = TRUE, position = "raincloud", alpha = .35, cex=.5) +
ggplot2::theme_classic() +
ggplot2::labs(x = "average depth in each sample", y = "m value (minimum stack depth)") +
ggplot2::theme(legend.position = "none")
)
#take m df output from all these possibilities
#plot number of SNPs retained colored by m at each filt level, as open circles
#plot the number of polymorphic loci retained colored by m at each filt level, as closed circles
#plot a vertical line at x=.8
#return a message as output telling the user to pick the m value with the most polyloci retained at r80 (.8)
#rename columns
colnames(m.df)<-c("m","filt","retained","snp.locus")
m.df$m<-as.character(m.df$m)
m.df$filt<-as.numeric(as.character(m.df$filt))
m.df$retained<-as.numeric(as.character(m.df$retained))
m.df$snp.locus<-as.character(m.df$snp.locus)
print("The optimal m value returns the most polymorphic loci in the 80% complete matrix (Paris et al. 2017)")
print(
ggplot2::ggplot(m.df, ggplot2::aes(x=filt, y=retained, col = m, shape=snp.locus))+
ggplot2::geom_point(alpha = .75, size=3)+
ggplot2::ggtitle("total SNPs and polymorphic loci retained by filtering scheme")+
ggplot2::xlab("fraction of non-missing genotypes required to retain each SNP (0-1)")+
ggplot2::ylab("# SNPs/loci")+
ggplot2::theme_light()+
ggplot2::geom_vline(xintercept=.8)+
ggplot2::labs(col = "min. stack depth", shape="")
)
#return the depth and snp/loci dataframes in case you want to do your own visualizations
out <- list()
out$depth<-depth.df
out$m.comparisons<-m.df
return(out)
#close function
}
setwd("/Users/devder/Desktop/chalcophaps.rad")
optimize_m(m3="m3.vcf",
m4="m4.vcf",
m5="m5.vcf",
m6="m6.vcf",
m7="m7.vcf")
setwd("~/Desktop/RADstackshelpR/vignettes/")
setwd("~/Desktop/RADstackshelpR/")
devtools::build_vignettes()
